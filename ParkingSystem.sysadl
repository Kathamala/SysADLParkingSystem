Model SysADLModel ; package SysADL.types { value type Int { } value type Boolean { } value type String { } value type Void { } value type Real { } datatype Ticket { attributes :  entranceTime : DateTime ; validatedTime : DateTime ; barcode : String ; helpText : String ; exitTime : DateTime ; vehicle : Vehicle ; ticketStatus : TicketStatus ; } dimension ColorD value type Color { dimension = ColorD } value type DateTime { } datatype FiscalNote { attributes : ticket : Ticket ; costPrice : Price ; payedPrice : Price ; address : String ; paymentType : PaymentType ; } dimension PriceD value type Price { unit = Real dimension = PriceD } enum PaymentType { DEBIT_CARD , CREDIT_CARD , PIX , CASH } unit Real { dimension = PriceD } unit Green { dimension = ColorD } value type GreenColor extends Color { unit = Green dimension = ColorD } unit Red { dimension = ColorD } unit Blue { dimension = ColorD } value type RedColor extends Color { unit = Red dimension = ColorD } value type BlueColor extends Color { unit = Blue dimension = ColorD } enum Command { ON , OFF } datatype Vehicle { attributes : driver : String ; licensePlate : String ; } enum TicketStatus { VALIDATED , NON_VALIDATED } datatype Spot { attributes : id : Int ; occupied : Boolean ; } datatype LED { attributes : id : Int ; color : Color ; } }  Requirement CalculateFeeFR ( 1.6 ) { text = "\"The system must calculate the vehicle parking fee when the client is paying for the ticket\"." derive ParkingSystemRequirements.ParkingSystemFR.MakePaymentFR ; }  Requirement IssueReceiptFR ( 1.7 ) { text = "\"The system must provide the user with the ability to issue the payment receipt\"." derive ParkingSystemRequirements.ParkingSystemFR.MakePaymentFR ; }  Requirement MasterKeyFR ( 1.10 ) { text = "\"The system must provide the operator with the ability to open the parking gate with the master key\"." derive ParkingSystemRequirements.ParkingSystemFR ; }  Requirement ParkingLotConfigurationsFR ( 1.11 ) { text = "\"The system must provide the administrator with the ability to define configurations for the parking lot\"." derive ParkingSystemRequirements.ParkingSystemFR ; }  Requirement DetectVacancyFR ( 1.12 ) { text = "\"The system must automatically detect the occupation of a parking spot\"." derive ViewStatusFR ; }  Requirement GenerateReportFR ( 1.13 ) { text = "\"The system must be able to generate usage reports, including occupation statistics, rush hour and profit\"." derive ParkingSystemRequirements.ParkingSystemFR ; } Requirement AvailabilityNFR ( 2.5 ) { text = "\"The inactivity time planned for maintenance must not affect the operations during the parking lot opening hours\"." derive ParkingSystemRequirements.QualityNFR.AvailabilityNFR ; } Requirement UsabilityNFR ( 2.8 ) { text = "\"The warnings and instructions must be clear and comprehensible\"." derive ParkingSystemRequirements.QualityNFR.UsabilityNFR ; } Requirement FaultToleranceNFR ( 2.10 ) { text = "\"The system must have redundancy in critical services\"." derive ParkingSystemRequirements.QualityNFR.FaultToleranceNFR ; } Requirement ParkingSystemRequirements ( 0 ) { text = "\"The system must satisfy the functional and non-functional concerns\"." Requirement ParkingSystemFR ( 1 ) { text = "\"The system must be able to manage the vehicles entering and leaving the parking lot\"." Requirement RegisterVehicleFR ( 1.1 ) { text = "\"The system must register the vehicle in the parking lot entrance\"." derive ParkingSystemFR ; Requirement OpenParkingGateFR ( 1.9 ) { text = "\"The system must automatically open the exit parking gate if the vehicle has a validated ticket\"." } Requirement IssueTicketFR ( 1.4 ) { text = "\"The system must provide the user with the ability to issue a validation ticket at the parking lot entrance\"." } } Requirement MakePaymentFR ( 1.5 ) { text = "\"The system must provide the user with the ability to make the payment, and validate the ticket\"." derive ParkingSystemFR ; } Requirement ExitParkingGateFR ( 1.8 ) { text = "\"The system must provide the user with the ability to request the opening of the parking gate, if the ticket is validated\"." derive ParkingSystemFR ; } } Requirement QualityNFR ( 2 ) { text = "\"The system must satisfy the performance, security, conformity, scalability, usability,fault tolerance and availability\"." Requirement AvailabilityNFR ( 2.4 ) { text = "\"The entrace/leaving controlling system must be available 24 hours a day, 7 days a week\"." } Requirement FaultToleranceNFR ( 2.9 ) { text = "\"The system must be projected to tolerate hardware and software faults without interrupting the services\"." } Requirement UsabilityNFR ( 2.7 ) { text = "\"The system must be easy to use for the operators and clients, with an intuitive interface\"." } Requirement PerformanceNFR ( 2.1 ) { text = "\"The system must be able to process the entrance/leaving of a vehicle in less than 5 seconds\"." } Requirement SecurityNFR ( 2.3 ) { text = "\"The system must be able to ensure the client darta and financial transfers protection\"." } Requirement PerformanceNFR ( 2.2 ) { text = "\"The waiting time at the entrace/leaving line must not exceed 10 minutes, including during the rush hour\"." } Requirement ScalabilityNFR ( 2.6 ) { text = "\"The system must be able to horizontally scale in order to support the increase of demand during events\"." } Requirement ConformityNFR ( 2.11 ) { text = "\"The system must be in conformity with all the local, stadual and national regulations regarding paid parking lots, data privacy and security\"." } } } Requirement ViewPricesFR ( 1.2 ) { text = "\"The system must provide the user with the ability to view the parking lot prices at the entrance station\"." derive ParkingSystemRequirements.ParkingSystemFR ; } Requirement ViewStatusFR ( 1.3 ) { text = "\"The system must provide the user with the ability to view the parking lot status at the entrance station\"." derive ParkingSystemRequirements.ParkingSystemFR ; } package ParkingSystemConnectors { import ParkingSystemPorts ; connector def CaptureLincesePlateCN { participants : ~ source : LicensePlateOPT ; ~ target : LicensePlateIPT ; flows : String from source to target } connector def SendTicketCN { participants : ~ source : TicketOPT ; ~ target : TicketIPT ; flows : Ticket from source to target } connector def SendCommandCN { participants : ~ source : CommandOPT ; ~ target : CommandIPT ; flows : Command from source to target }   connector def SendQuantityCN { participants : ~ source : QuantityOPT ; ~ target : QuantityIPT ; flows : Int from source to target } connector def SendVehicleCN { participants : ~ source : VehicleOPT ; ~ target : VehicleIPT ; flows : Vehicle from source to target } connector def SendStatusCN { participants : ~ source : StatusOPT ; ~ target : StatusIPT ; flows : Int from source to target } connector def SendFiscalNoteCN { participants : ~ source : FiscalNoteOPT ; ~ target : FiscalNoteIPT ; flows : FiscalNote from source to target } connector def SendPaymentCN { participants : ~ target : PaymentMadeIPT ; ~ source : PaymentMadeOPT ; flows : Boolean from source to target } connector def EmitPresenceCN { participants : ~ source : SpotIPT ; ~ target : SpotOPT ; flows : Spot from source to target } connector def EmitColorCN { participants : ~ target : LEDIPT ; ~ source : LEDOPT ; flows : LED from source to target }  connector def SendStatusTicketCN { participants : ~ sourceTicket : TicketOPT ; ~ targetTicket : TicketIPT ; ~ targetStatus : StatusOPT ; ~ sourceStatus : StatusIPT ; flows : Ticket from sourceTicket to targetTicket Int from targetStatus to sourceStatus } } package ParkingSystemComponents { import ParkingSystemPorts ; import SysADL.types ; import ParkingSystemConnectors ;
	component def ParkingControllerCP { ports :  gate : CommandOPT ;  ticket : StatusTicketCPT ; configuration { components : hb : HeartbeaterCP { using ports : status : StatusOPT ; } delegations : status to status } } boundary
	component def ExitInterfaceCP { ports : ticket : TicketOPT ; code : CodeIPT ; } boundary
	component def PaymentInterfaceCP { ports : ticket : TicketOPT ; mode : PaymentMadeOPT ;  } boundary
	component def EntranceInterfaceCP { ports : driver : ButtonPressIPT ; vehicle : VehicleOPT ;  }
	component def PaymentControllerCP { ports : ticket : TicketIPT ; voucher : FiscalNoteOPT ; payment : PaymentMadeIPT ; ticketValidated : TicketOPT ; } boundary
	component def GateCP { ports : state : CommandIPT ;  } boundary
	component def CameraCP { ports :   plate : LicensePlateOPT ; } boundary
	component def ParkingInterfaceCP { ports :  quantity : QuantityIPT ; }
	component def ParkingSystem { configuration { components :             pc : PaymentControllerCP { using ports : ticketRecieved : TicketIPT ; voucher : FiscalNoteOPT ; payment : PaymentMadeIPT ; ticketValidated : TicketOPT ; } pi : PaymentInterfaceCP { using ports : ticketEmitted : TicketOPT ; mode : PaymentMadeOPT ;  } ps : PresenceSensorCP [ 1 , 100 ] { using ports : presence : SpotOPT ; }  ui2 : ExitInterfaceCP { using ports : ticketRead : TicketOPT ; code : CodeIPT ; } rp : ReceiptPrinterCP { using ports : fiscalNote : FiscalNoteIPT ; } led : LEDCP [ 1 , 100 ] { using ports : stt2 : LEDIPT ; } sc : SpotControllerCP { using ports : availableVacancies : QuantityOPT ; spot : SpotIPT ; led : LEDOPT ; } gt : GateCP { using ports : state : CommandIPT ;  } tc : TicketControllerCP { using ports : newTicket : TicketOPT ; newVehicle : VehicleIPT ; } ei : EntranceInterfaceCP { using ports : driver : ButtonPressIPT ; vehicle : VehicleOPT ;  } pi : ParkingInterfaceCP { using ports : quantity : QuantityIPT ; }  mk : MasterKeyCP { using ports : key : CodeIPT ; g2 : CommandOPT ; } pc : ParkingControllerCP { using ports : g1 : CommandOPT ; ticket : StatusTicketCPT ; } em : ExitMonitorCP { using ports : ticketProcessed : TicketOPT ; plate : LicensePlateIPT ; } c1 : CameraCP { using ports : detected : LicensePlateOPT ; } connectors :            p1 : SendPaymentCN bindings mode = payment ; t5 : SendTicketCN bindings ticketEmitted = ticketRecieved ;       fn : SendFiscalNoteCN bindings voucher = fiscalNote ;  ep : EmitPresenceCN bindings presence = spot ; ec : EmitColorCN bindings led = stt2 ;  v1 : SendVehicleCN bindings vehicle = newVehicle ;   qtd : SendQuantityCN bindings availableVacancies = quantity ;      c2 : SendCommandCN bindings g2 = state ; c1 : SendCommandCN bindings g1 = state ; t1 : SendStatusTicketCN bindings newTicket = ticket ; t2 : SendStatusTicketCN bindings ticketRead = ticket ;  t4 : SendStatusTicketCN bindings ticketValidated = ticket ; clp : CaptureLincesePlateCN bindings detected = plate ; t3 : SendStatusTicketCN bindings ticketProcessed = ticket ; } }
	component def SpotControllerCP { ports :   vacancies : QuantityOPT ; spot : SpotIPT [ 1 , 100 ] ; led : LEDOPT ; } boundary
	component def PresenceSensorCP { ports :  presence : SpotOPT ; } boundary
	component def LEDCP { ports :  state : LEDIPT ; }
	component def TicketControllerCP { ports :  newTicket : TicketOPT ; vehicle : VehicleIPT ; }
	component def ExitMonitorCP { ports :  ticket : TicketOPT ;  plate : LicensePlateIPT ; } boundary
	component def ReceiptPrinterCP { ports : fiscalNote : FiscalNoteIPT ; }    activity def TicketControllerAC ( vehicle : Vehicle ) : ( ticket : Ticket ) { body { actions : generateTicket : TicketControllerAN { using pins : vehicle : Vehicle ; } delegate vehicle to vehicle delegate ticket to generateTicket } } activity def ParkingControllerAC ( ticket : Ticket ) : ( command : Command ) { body { actions : analyzeTicket : DefineCommandAN { using pins : ticket : Ticket ; } delegate ticket to ticket delegate command to analyzeTicket } }       activity def SpotControllerAC ( spot : Spot ) : ( availableVacancies : Int , colorLED : LED ) { body { actions :  getColor : NotifyColorAN { using pins : spot1 : Spot ; } calculate : NotifyVacanciesAN { using pins : spot2 : Spot ; }    delegate   spot to spot1    delegate   spot to spot2  delegate  colorLED to getColor delegate availableVacancies to calculate } }    action def TicketControllerAN ( vehicle : Vehicle ) : Ticket { }  action def DefineCommandAN ( ticket : Ticket ) : Command { }                     action def SendFiscalNoteAN ( validatedTicket : Ticket ) : FiscalNote { } action def SendTicketValidationAN ( ticket : Ticket , paymentMode : Boolean ) : Ticket { } activity def PaymentControllerAC ( ticket : Ticket ) ( paymentMade : Boolean ) : ( ticketValidated : Ticket , voucher : FiscalNote ) { body { actions : validate : SendTicketValidationAN { using pins : ticket : Ticket ; paymentMode : Boolean ; } generateReceipt : SendFiscalNoteAN { using pins : validatedTicket : Ticket ; }  delegate  ticketValidated to validate  delegate  ticket to ticket  delegate  paymentMade to paymentMode delegate voucher to generateReceipt flow from validate to validatedTicket } } action def NotifyColorAN ( spot1 : Spot ) : LED { }  action def NotifyVacanciesAN ( spot2 : Spot ) : Int { }
	component def MasterKeyCP { ports : key : CodeIPT ; gate : CommandOPT ; } activity def MasterKeyAC ( code : Int ) : ( command : Command ) { body { actions : ChangeGate : ChangeGateAN { using pins : code : Int ; } delegate code to code delegate command to ChangeGate } } action def ChangeGateAN ( code : Int ) : Command { }
	component def HeartbeaterCP { ports : status : StatusOPT ; } activity def HeartbeaterAC : ( status : Boolean ) { body { actions : set : SetStatusAN { using pins : periodicTesk : Void ; } delegate status to set } } action def SetStatusAN ( periodicTesk : Void ) : Boolean { } activity def ExitMonitorAC ( plate : String ) : ( ticket : Ticket ) { body { actions : find : FindTicketAN { using pins : plate : String ; } delegate ticket to find delegate plate to plate } }              action def FindTicketAN ( plate : String ) : Ticket { } } package ParkingSystemPorts { import SysADL.types ; port def ButtonPressIPT { flow in Boolean } port def TicketOPT { flow out Ticket }  port def TicketIPT { flow in Ticket } port def LicensePlateIPT { flow in String }  port def PaymentMadeOPT { flow out Boolean } port def FiscalNoteOPT { flow out FiscalNote } port def PresenceIPT { flow in Boolean } port def PriceOPT { flow out Price } port def StatusOPT { flow out Int }   port def PresenceOPT { flow out Boolean } port def LicensePlateOPT { flow out String }   port def PaymentMadeIPT { flow in Boolean }   port def CommandIPT { flow in Command } port def CommandOPT { flow out Command } port def StatusIPT { flow in Int } port def PriceIPT { flow in Price } port def VehicleIPT { flow in Vehicle } port def VehicleOPT { flow out Vehicle } port def QuantityIPT { flow in Int } port def QuantityOPT { flow out Int } port def FiscalNoteIPT { flow in FiscalNote } port def SpotIPT { flow in Spot } port def SpotOPT { flow in Spot } port def CodeIPT { flow in Int } port def LEDIPT { flow in LED } port def LEDOPT { flow out LED } port def ResponseLicensePlateCPT { ports : query : CommandIPT ; answer : LicensePlateOPT ; } port def RequestLicensePlateCPT { ports : query : CommandOPT ; answer : LicensePlateIPT ; } port def StatusTicketCPT { ports : ticket : TicketIPT ; status : StatusOPT ; } }