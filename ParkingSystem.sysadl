Model SysADLModel ; package SysADL.types { value type Int { } value type Boolean { } value type String { } value type Void { } value type Real { } datatype Ticket { attributes :  entranceTime : DateTime ; validatedTime : DateTime ; barcode : String ; helpText : String ; exitTime : DateTime ; vehicle : Vehicle ; ticketStatus : TicketStatus ; } dimension ColorD value type Color { dimension = ColorD } value type DateTime { } datatype FiscalNote { attributes : ticket : Ticket ; costPrice : Price ; payedPrice : Price ; address : String ; paymentType : PaymentType ; } dimension PriceD value type Price { unit = Real dimension = PriceD } enum PaymentType { DEBIT_CARD , CREDIT_CARD , PIX , CASH } unit Real { dimension = PriceD } unit Green { dimension = ColorD } value type GreenColor extends Color { unit = Green dimension = ColorD } unit Red { dimension = ColorD } unit Blue { dimension = ColorD } value type RedColor extends Color { unit = Red dimension = ColorD } value type BlueColor extends Color { unit = Blue dimension = ColorD } enum Command { ON , OFF } datatype Vehicle { attributes : driver : String ; licensePlate : String ; } enum TicketStatus { VALIDATED , NON_VALIDATED } datatype Spot { attributes : id : Int ; occupied : Boolean ; } datatype LED { attributes : id : Int ; color : Color ; } }  Requirement CalculateFeeFR ( 1.6 ) { text = "\"The system must calculate the vehicle parking fee when the client is paying for the ticket\"." derive ParkingSystemRequirements.ParkingSystemFR.MakePaymentFR ; }  Requirement IssueReceiptFR ( 1.7 ) { text = "\"The system must provide the user with the ability to issue the payment receipt\"." derive ParkingSystemRequirements.ParkingSystemFR.MakePaymentFR ; }  Requirement MasterKeyFR ( 1.10 ) { text = "\"The system must provide the operator with the ability to open the parking gate with the master key\"." derive ParkingSystemRequirements.ParkingSystemFR ; }  Requirement ParkingLotConfigurationsFR ( 1.11 ) { text = "\"The system must provide the administrator with the ability to define configurations for the parking lot\"." derive ParkingSystemRequirements.ParkingSystemFR ; }  Requirement DetectVacancyFR ( 1.12 ) { text = "\"The system must automatically detect the occupation of a parking spot\"." derive ViewStatusFR ; }  Requirement GenerateReportFR ( 1.13 ) { text = "\"The system must be able to generate usage reports, including occupation statistics, rush hour and profit\"." derive ParkingSystemRequirements.ParkingSystemFR ; } Requirement AvailabilityNFR ( 2.5 ) { text = "\"The inactivity time planned for maintenance must not affect the operations during the parking lot opening hours\"." derive ParkingSystemRequirements.QualityNFR.AvailabilityNFR ; } Requirement UsabilityNFR ( 2.8 ) { text = "\"The warnings and instructions must be clear and comprehensible\"." derive ParkingSystemRequirements.QualityNFR.UsabilityNFR ; } Requirement FaultToleranceNFR ( 2.10 ) { text = "\"The system must have redundancy in critical services\"." derive ParkingSystemRequirements.QualityNFR.FaultToleranceNFR ; } Requirement ParkingSystemRequirements ( 0 ) { text = "\"The system must satisfy the functional and non-functional concerns\"." Requirement ParkingSystemFR ( 1 ) { text = "\"The system must be able to manage the vehicles entering and leaving the parking lot\"." Requirement RegisterVehicleFR ( 1.1 ) { text = "\"The system must register the vehicle in the parking lot entrance\"." derive ParkingSystemFR ; Requirement OpenParkingGateFR ( 1.9 ) { text = "\"The system must automatically open the exit parking gate if the vehicle has a validated ticket\"." } Requirement IssueTicketFR ( 1.4 ) { text = "\"The system must provide the user with the ability to issue a validation ticket at the parking lot entrance\"." } } Requirement MakePaymentFR ( 1.5 ) { text = "\"The system must provide the user with the ability to make the payment, and validate the ticket\"." derive ParkingSystemFR ; } Requirement ExitParkingGateFR ( 1.8 ) { text = "\"The system must provide the user with the ability to request the opening of the parking gate, if the ticket is validated\"." derive ParkingSystemFR ; } } Requirement QualityNFR ( 2 ) { text = "\"The system must satisfy the performance, security, conformity, scalability, usability,fault tolerance and availability\"." Requirement AvailabilityNFR ( 2.4 ) { text = "\"The entrace/leaving controlling system must be available 24 hours a day, 7 days a week\"." } Requirement FaultToleranceNFR ( 2.9 ) { text = "\"The system must be projected to tolerate hardware and software faults without interrupting the services\"." } Requirement UsabilityNFR ( 2.7 ) { text = "\"The system must be easy to use for the operators and clients, with an intuitive interface\"." } Requirement PerformanceNFR ( 2.1 ) { text = "\"The system must be able to process the entrance/leaving of a vehicle in less than 5 seconds\"." } Requirement SecurityNFR ( 2.3 ) { text = "\"The system must be able to ensure the client darta and financial transfers protection\"." } Requirement PerformanceNFR ( 2.2 ) { text = "\"The waiting time at the entrace/leaving line must not exceed 10 minutes, including during the rush hour\"." } Requirement ScalabilityNFR ( 2.6 ) { text = "\"The system must be able to horizontally scale in order to support the increase of demand during events\"." } Requirement ConformityNFR ( 2.11 ) { text = "\"The system must be in conformity with all the local, stadual and national regulations regarding paid parking lots, data privacy and security\"." } } } Requirement ViewPricesFR ( 1.2 ) { text = "\"The system must provide the user with the ability to view the parking lot prices at the entrance station\"." derive ParkingSystemRequirements.ParkingSystemFR ; } Requirement ViewStatusFR ( 1.3 ) { text = "\"The system must provide the user with the ability to view the parking lot status at the entrance station\"." derive ParkingSystemRequirements.ParkingSystemFR ; } package ParkingSystemConnectors { import ParkingSystemPorts ; connector def CaptureLincesePlateCN { participants : ~ source : LicensePlateOPT ; ~ target : LicensePlateIPT ; flows : String from source to target } connector def SendTicketCN { participants : ~ source : TicketOPT ; ~ target : TicketIPT ; flows : Ticket from source to target } connector def SendCommandCN { participants : ~ source : CommandOPT ; ~ target : CommandIPT ; flows : Command from source to target }   connector def SendQuantityCN { participants : ~ source : QuantityOPT ; ~ target : QuantityIPT ; flows : Int from source to target } connector def SendVehicleCN { participants : ~ source : VehicleOPT ; ~ target : VehicleIPT ; flows : Vehicle from source to target } connector def SendStatusCN { participants : ~ source : StatusOPT ; ~ target : StatusIPT ; flows : Int from source to target } connector def SendFiscalNoteCN { participants : ~ source : FiscalNoteOPT ; ~ target : FiscalNoteIPT ; flows : FiscalNote from source to target } connector def SendPaymentCN { participants : ~ target : PaymentMadeIPT ; ~ source : PaymentMadeOPT ; flows : Boolean from source to target } connector def EmitPresenceCN { participants : ~ source : SpotIPT ; ~ target : SpotOPT ; flows : Spot from source to target } connector def EmitColorCN { participants : ~ target : LEDIPT ; ~ source : LEDOPT ; flows : LED from source to target } connector def LicensePlateCCN { participants : ~ sourceQuery : CommandOPT ; ~ tergetQuery : CommandIPT ; ~ sourceAnswer : LicensePlateIPT ; ~ targetAnswer : LicensePlateOPT ; flows : Command from sourceQuery to tergetQuery String from targetAnswer to sourceAnswer } } package ParkingSystemComponents { import ParkingSystemPorts ; import SysADL.types ; import ParkingSystemConnectors ;
	component def ParkingControllerCP { ports : ticket : TicketIPT ; gate : CommandOPT ;  } boundary
	component def ExitInterfaceCP { ports : ticket : TicketOPT ; code : CodeIPT ; } boundary
	component def PaymentInterfaceCP { ports : ticket : TicketOPT ; mode : PaymentMadeOPT ;  } boundary
	component def EntranceInterfaceCP { ports : driver : ButtonPressIPT ; vehicle : VehicleOPT ; requestLicensePlate : RequestLicensePlateCPT ; }
	component def PaymentControllerCP { ports : ticket : TicketIPT ; voucher : FiscalNoteOPT ; payment : PaymentMadeIPT ; ticketValidated : TicketOPT ; }
	component def GateCP { ports : state : CommandIPT ; masterKey : CommandIPT ; }
	component def CameraCP { ports :  responseLicensePlate : ResponseLicensePlateCPT ; }
	component def ParkingInterfaceCP { ports :  quantity : QuantityIPT ; }
	component def ParkingSystem { configuration { components :             pc : PaymentControllerCP { using ports : ticketRecieved : TicketIPT ; voucher : FiscalNoteOPT ; payment : PaymentMadeIPT ; ticketValidated : TicketOPT ; } pi : PaymentInterfaceCP { using ports : ticketEmitted : TicketOPT ; mode : PaymentMadeOPT ;  } ps : PresenceSensorCP [ 1 , 100 ] { using ports : presence : SpotOPT ; }  ui2 : ExitInterfaceCP { using ports : ticketRead : TicketOPT ; code : CodeIPT ; } rp : ReceiptPrinterCP { using ports : fiscalNote : FiscalNoteIPT ; } LEDCP : LEDCP [ 1 , 100 ] { using ports : stt2 : LEDIPT ; } SpotControllerCP : SpotControllerCP { using ports : availableVacancies : QuantityOPT ; spot : SpotIPT ; led : LEDOPT ; } GateCP : GateCP { using ports : state : CommandIPT ; masterKey : CommandIPT ; } TicketControllerCP : TicketControllerCP { using ports : newTicket : TicketOPT ; newVehicle : VehicleIPT ; } EntranceInterfaceCP : EntranceInterfaceCP { using ports : driver : ButtonPressIPT ; vehicle : VehicleOPT ; req1 : RequestLicensePlateCPT ; } CameraCP : CameraCP { using ports : res1 : ResponseLicensePlateCPT ; } ExitMonitorCP : ExitMonitorCP { using ports : ticketProcessed : TicketOPT ; req2 : RequestLicensePlateCPT ; } CameraCP : CameraCP { using ports : res2 : ResponseLicensePlateCPT ; } ParkingInterfaceCP : ParkingInterfaceCP { using ports : quantity : QuantityIPT ; } ParkingControllerCP : ParkingControllerCP { using ports : ticket : TicketIPT ; gate : CommandOPT ; } connectors :            p1 : SendPaymentCN bindings mode = payment ; t5 : SendTicketCN bindings ticketEmitted = ticketRecieved ;       fn : SendFiscalNoteCN bindings voucher = fiscalNote ;  ep : EmitPresenceCN bindings presence = spot ; ec : EmitColorCN bindings led = stt2 ;  v1 : SendVehicleCN bindings vehicle = newVehicle ; r1 : LicensePlateCCN bindings res1 = req1 ; r2 : LicensePlateCCN bindings req2 = res2 ; qtd : SendQuantityCN bindings availableVacancies = quantity ; t1 : SendTicketCN bindings newTicket = ticket ; t2 : SendTicketCN bindings ticketRead = ticket ; t3 : SendTicketCN bindings ticketProcessed = ticket ; t4 : SendTicketCN bindings ticketValidated = ticket ; c1 : SendCommandCN bindings gate = state ; } }
	component def SpotControllerCP { ports :   vacancies : QuantityOPT ; spot : SpotIPT [ 1 , 100 ] ; led : LEDOPT ; }
	component def PresenceSensorCP { ports :  presence : SpotOPT ; }
	component def LEDCP { ports :  state : LEDIPT ; }
	component def TicketControllerCP { ports :  newTicket : TicketOPT ; vehicle : VehicleIPT ; }
	component def ExitMonitorCP { ports :  ticket : TicketOPT ; requestLicensePlate : RequestLicensePlateCPT ; } component def ReceiptPrinterCP { ports : fiscalNote : FiscalNoteIPT ; } activity def EntranceInterfaceAC ( button : Boolean ) : ( vehicle : Vehicle ) { body { actions : EntranceInterfaceAN : EntranceInterfaceAN { using pins : button : Boolean ; } CameraAN : CameraAN { using pins : query : Command ; } EntranceResultAN : EntranceResultAN { using pins : licensePlate : String ; } flow from EntranceInterfaceAN to query delegate button to button flow from CameraAN to licensePlate delegate vehicle to EntranceResultAN } } action def EntranceInterfaceAN ( button : Boolean , licensePlate : String ) : Command { constraint : post-condition GenerateEntranceVehicleEQ delegate button to button delegate EntranceInterfaceAN to vehicle } constraint GenerateEntranceVehicleEQ ( button : Boolean ) : ( vehicle : Vehicle ) { } activity def CameraAC ( query : Command ) : ( newPin : String ) { body { actions : CameraAN : CameraAN { using pins : query : Command ; } delegate query to query delegate newPin to CameraAN } } activity def TicketControllerAC ( vehicle : Vehicle ) : ( ticket : Ticket ) { body { actions : TicketControllerAN : TicketControllerAN { using pins : vehicle : Vehicle ; } delegate vehicle to vehicle delegate ticket to TicketControllerAN } } activity def ParkingControllerEntranceAC ( ticket : Ticket ) : ( command : Command ) { body { actions : EntranceCommandAN : EntranceCommandAN { using pins : ticket : Ticket ; } delegate ticket to ticket delegate command to EntranceCommandAN } } activity def ExitInterfaceAC ( code : Int ) : ( ticket : Ticket ) { body { actions : ExitInterfaceAN : ExitInterfaceAN { using pins : code : Int ; } delegate code to code delegate ticket to ExitInterfaceAN } } activity def ExitMonitorAC : ( ticket : Ticket ) { body { actions : ExitMonitorQueryAN : ExitMonitorQueryAN { using pins : periodicTask : Void ; } ExitMonitorResultAN : ExitMonitorResultAN { using pins : licensePlate : String ; } CameraAN : CameraAN { using pins : query : Command ; } flow from ExitMonitorQueryAN to query flow from CameraAN to licensePlate delegate ticket to ExitMonitorResultAN } } activity def ParkingInterfaceAC ( quantity : Int ) { body { actions : ShowStatus : ShowStatusAN { using pins : quantity : Int ; } delegate quantity to quantity } } activity def ReceiptPrinterAC ( fiscalNote : FiscalNote ) { body { actions : PrintFiscalNoteAN : PrintFiscalNoteAN { using pins : fiscalNote : String ; } delegate fiscalNote to fiscalNote } } activity def PaymentControllerFiscalNoteAC ( ticketRecieved : Ticket ) ( paymentMade : Boolean ) : ( voucher : FiscalNote ) { body { actions : SendFiscalNoteAN : SendFiscalNoteAN { using pins : ticket : Ticket ; paymentMade : Boolean ; } delegate voucher to SendFiscalNoteAN delegate ticketRecieved to ticket delegate paymentMade to paymentMade } } activity def GateAC ( state : Command ) ( masterKey : Command ) { body { actions : OpenGateAN : OpenGateAN { using pins : command : Command ; } delegate state to command delegate masterKey to command } } activity def SpotControllerIncreaseAC ( spot : Spot ) : ( availableVacancies : Int ) { body { actions : IncreaseQuantityAN : IncreaseQuantityAN { using pins : spot : Spot ; } delegate availableVacancies to IncreaseQuantityAN delegate spot to spot } } activity def LEDAC ( led : LED ) { body { actions : UpdateLEDColorAN : UpdateLEDColorAN { using pins : LED : LED ; } delegate led to LED } } activity def PaymentInterfaceAC : ( TicketEmitted : Ticket , mode : Boolean ) { body { actions : EmitTicketAN : EmitTicketAN { using pins : userAction : Void ; } EmitPaymentMadeAN : EmitPaymentMadeAN { using pins : userAction : Void ; } delegate mode to EmitPaymentMadeAN delegate TicketEmitted to EmitTicketAN } } activity def PresenceSensorAC : ( spot : Spot ) { body { actions : SpotStatusAN : SpotStatusAN { using pins : sensor : Void ; } delegate spot to SpotStatusAN } } action def TicketControllerAN ( vehicle : Vehicle ) : Ticket { } action def OpenGateAN ( command : Command ) : Void { } action def EntranceCommandAN ( ticket : Ticket ) : Command { } action def SavePaymentMadeAN ( ticket : Ticket ) : Void { } action def CheckTicketValidatedAN ( ticket : Ticket ) : Command { } action def IncreaseQuantityAN ( spot : Spot ) : Int { } action def DecreaseQuantityAN ( spot : Spot ) : Int { } activity def ParkingControllerExitAC ( ticket : Ticket ) : ( command : Command , status : Int ) { body { actions : CheckTicketValidatedAN : CheckTicketValidatedAN { using pins : ticket : Ticket ; } delegate ticket to ticket delegate command to CheckTicketValidatedAN } } activity def ParkingControllerPaymentAC ( ticket : Ticket ) { body { actions : SavePaymentMadeAN : SavePaymentMadeAN { using pins : ticket : Ticket ; } delegate ticket to ticket } } action def CameraAN ( query : Command ) : String { } action def EntranceResultAN ( licensePlate : String ) : Vehicle { } action def ExitMonitorResultAN ( licensePlate : String ) : Ticket { } action def ExitMonitorQueryAN ( periodicTask : Void ) : Command { } action def ExitInterfaceAN ( code : Int ) : Ticket { } action def ShowStatusAN ( quantity : Int ) : Void { } action def PrintFiscalNoteAN ( fiscalNote : String ) : Void { } action def SpotStatusAN ( sensor : Void ) : Spot { } action def SetLEDAN ( spot : Spot ) : LED { } activity def SpotControllerDecreaseAC ( spot : Spot ) : ( availableVacancies : Int ) { body { actions : DecreaseQuantityAN : DecreaseQuantityAN { using pins : spot : Spot ; } delegate availableVacancies to DecreaseQuantityAN delegate spot to spot } } activity def SpotControllerLEDAC ( spot : Spot ) : ( LED : LED ) { body { actions : SetLEDAN : SetLEDAN { using pins : spot : Spot ; } delegate LED to SetLEDAN delegate spot to spot } } action def UpdateLEDColorAN ( LED : LED ) : Void { } action def EmitTicketAN ( userAction : Void ) : Ticket { } action def EmitPaymentMadeAN ( userAction : Void ) : Boolean { } action def SendFiscalNoteAN ( ticket : Ticket , paymentMade : Boolean ) : FiscalNote { } action def SendTicketValidationAN ( ticket : Ticket , paymentMade : Boolean ) : Ticket { } activity def PaymentControllerTicketAC ( ticket : Ticket ) ( paymentMade : Boolean ) : ( ticketValidated : Ticket ) { body { actions : SendTicketValidationAN : SendTicketValidationAN { using pins : ticket : Ticket ; paymentMade : Boolean ; } delegate ticket to ticket delegate paymentMade to paymentMade delegate ticketValidated to SendTicketValidationAN } } } package ParkingSystemPorts { import SysADL.types ; port def ButtonPressIPT { flow in Boolean } port def TicketOPT { flow out Ticket }  port def TicketIPT { flow in Ticket } port def LicensePlateIPT { flow in String }  port def PaymentMadeOPT { flow out Boolean } port def FiscalNoteOPT { flow out FiscalNote } port def PresenceIPT { flow in Boolean } port def PriceOPT { flow out Price } port def StatusOPT { flow out Int }   port def PresenceOPT { flow out Boolean } port def LicensePlateOPT { flow out String }   port def PaymentMadeIPT { flow in Boolean }   port def CommandIPT { flow in Command } port def CommandOPT { flow out Command } port def StatusIPT { flow in Int } port def PriceIPT { flow in Price } port def VehicleIPT { flow in Vehicle } port def VehicleOPT { flow out Vehicle } port def QuantityIPT { flow in Int } port def QuantityOPT { flow out Int } port def FiscalNoteIPT { flow in FiscalNote } port def SpotIPT { flow in Spot } port def SpotOPT { flow in Spot } port def CodeIPT { flow in Int } port def LEDIPT { flow in LED } port def LEDOPT { flow out LED } port def ResponseLicensePlateCPT { ports : query : CommandIPT ; answer : LicensePlateOPT ; } port def RequestLicensePlateCPT { ports : query : CommandOPT ; answer : LicensePlateIPT ; } }